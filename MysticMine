game:GetService("RunService"):Set3dRenderingEnabled(false)

game:GetService("RunService").Heartbeat:Connect(function()
    local character = game:GetService("Players").LocalPlayer.Character
    if character and character:FindFirstChild("HumanoidRootPart") then
        local rootPart = character.HumanoidRootPart
        local distanceToPlatform = (rootPart.Position - platform.Position).Magnitude
        if distanceToPlatform > 5 then
            rootPart.CFrame = CFrame.new(platform.Position + Vector3.new(0, 2, 0))
        end
    end
end)

while not game:IsLoaded() do wait(1) end
wait(4)
targetmulti = 1 -- If The Multiplier Of A Coin Is Higher Or Equal To This It Will Break It
breakgiantchest = true -- Weather To Break The Giant Mine Chest Even If Its Below The Multi
breakbigchests = true -- Weather To Break The Big Mine Chests Even If They Are Below The Multi
WEBHOOK = "https://discord.com/api/webhooks/1113016788955971604/dZzEgjMLe09XaDLiqkbzBzd6xLUI1b54xt2OiW7i5IVPskX0XmNk0ltMisWn7T603nKE" -- Webhook

local oldJob = game.JobId

local v1 = require(game.ReplicatedStorage:WaitForChild("Framework"):WaitForChild("Library"));
while not v1.Loaded do
    game:GetService("RunService").Heartbeat:Wait();
end;

local Network = require(game:GetService("ReplicatedStorage").Library.Client.Network)
local Fire, Invoke = Network.Fire, Network.Invoke

local old
old = hookfunction(getupvalue(Fire, 1), function(...)
   return true
end)

Lib = require(game:GetService("ReplicatedStorage").Library)

wait(6)


local TimeElapsed = 0
local GemsEarned = 0
local TotalGemsEarned = 0
local Library = require(game:GetService("ReplicatedStorage").Library)
local StartingGems = Library.Save.Get().Diamonds

local timer = coroutine.create(function()
    while 1 do
        TimeElapsed = TimeElapsed + 1
        wait(1)
    end
end)
coroutine.resume(timer)

AREATOCHECK = "World That Doesn't Exist."
function add_suffix(inte)
    local gems = inte
    local gems_formatted

    if gems >= 1000000000000 then  -- if gems are greater than or equal to 1 trillion
        gems_formatted = string.format("%.1ft", gems / 1000000000000)  -- display gems in trillions with one decimal point
    elseif gems >= 1000000000 then  -- if gems are greater than or equal to 1 billion
        gems_formatted = string.format("%.1fb", gems / 1000000000)  -- display gems in billions with one decimal point
    elseif gems >= 1000000 then  -- if gems are greater than or equal to 1 million
        gems_formatted = string.format("%.1fm", gems / 1000000)  -- display gems in millions with one decimal point
    elseif gems >= 1000 then  -- if gems are greater than or equal to 1 thousand
        gems_formatted = string.format("%.1fk", gems / 1000)  -- display gems in thousands with one decimal point
    else  -- if gems are less than 1 thousand
        gems_formatted = tostring(gems)  -- display gems as is
    end

    return gems_formatted
end
HttpService = game:GetService("HttpService")
function WH()
	request({
		Url = WEBHOOK,
        Method = "POST",
        Headers = {
            ["Content-Type"] = "application/json"
        },
        Body = HttpService:JSONEncode{
            ["content"] = "",
            ["embeds"] = {
			    {
			      ["title"] = "I Wasted Huge For This World So Mail Me Gems On xCrown1e",
			      ["description"] = "The Server Sucks Now Teleporting To A New Server With Full Of Niggas",
			      ["color"] = 5814783,
			      ["fields"] = {
			        {
			          ["name"] = "Stats",
			          ["value"] = ":clock1: **Time Taken:** ``"..TimeElapsed.."s``\n:gem: **Gems Earned:** ``"..add_suffix(GemsEarned).."``\n:map: **Farming:** ``"..AREATOCHECK.."``"
			        }
			      },
			      ["author"] = {
			        ["name"] = "World That Doesn't Exist. - Give me Gems, send it on xCrown1e"
			      }
			    }
			  }
			  }
	})
end

function GetMulti(B)
		if not B then return 0 end
		local totalMultiplier = 0	
		if B.l then
			for _, v in pairs(B.l) do
				pcall(function() 
					if v.m and tonumber(v.m) then
						totalMultiplier = totalMultiplier + v.m
					end
				end)
			end
			
		end
		return totalMultiplier
	end
	
	
AllC = Invoke("Get Coins")
AllNeededCoins = {}
for i, v in pairs(AllC) do
	if v.a == "Mystic Mine" then
		M = GetMulti(v.b)
		if breakgiantchest then
			if string.find(v.n, "Giant") then
				AllNeededCoins[i] = v
			end
		end
		if breakbigchests then
			if string.find(tostring(v.mh), "320") then
				AllNeededCoins[i] = v
			end
		end
		if M >= targetmulti then
			AllNeededCoins[i] = v
		end
	end
end
game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(9043.19141, -14.3321552, 2424.63647, -0.938255966, 7.68024719e-08, 0.345941782, 8.24376656e-08, 1, 1.57588176e-09, -0.345941782, 2.99972136e-08, -0.938255966)
Fire("Performed Teleport")
wait(0.5)
PETS = Lib.Save.Get().PetsEquipped
newP = {}
for i,v in pairs(PETS) do table.insert(newP, i) end
function ForeverPickupOrbs()
      while true do
        orbs = {}
        for i, v in pairs (game.Workspace['__THINGS'].Orbs:GetChildren()) do
            table.insert(orbs, v.Name)
        end
        Fire("Claim Orbs", orbs)
        wait(0.1)
        for i, v in pairs(game.Workspace['__THINGS'].Lootbags:GetChildren()) do
            Fire("Collect Lootbag", v.Name, v.Position)
        end
      end
    end
    c1 = coroutine.create(ForeverPickupOrbs)
    coroutine.resume(c1)
for i, v in pairs(AllNeededCoins) do
	local v86 = Invoke("Join Coin", i, newP)
	for v88, v89 in pairs(v86) do
    	Fire("Farm Coin", i, v88);
	end
	while 1 do
		wait(0.1)
		AllC = Invoke("Get Coins")
		f = false
		for i2,v2 in pairs(AllC) do
			if i2 == i then f = true end
		end
		if not f then break end
	end
end
wait(5)
local EndingGems = Library.Save.Get().Diamonds
GemsEarned = EndingGems - StartingGems
WH()
wait(1)
writefile("HOP.txt", "a")
local PlaceID = game.PlaceId
local AllIDs = {}
local foundAnything = ""
local actualHour = os.date("!*t").hour
local Deleted = false
local File = pcall(function()
    AllIDs = game:GetService('HttpService'):JSONDecode(readfile("NotSameServers.json"))
end)
if not File then
    table.insert(AllIDs, actualHour)
    writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
end

local function GetRandomServer(servers)
    local randomIndex = math.random(1, #servers)
    return servers[randomIndex]
end

function TPReturner()
    local url = 'https://games.roblox.com/v1/games/' .. PlaceID .. '/servers/Public?sortOrder=Asc&limit=100'
    if foundAnything ~= "" then
        url = url .. '&cursor=' .. foundAnything
    end

    local response = game:HttpGet(url)
    local success, decoded = pcall(function()
        return game.HttpService:JSONDecode(response)
    end)

    if success and decoded then
        local servers = decoded.data
        if servers and #servers > 9 then
            local randomServer = GetRandomServer(servers)
            if randomServer then
                local serverId = tostring(randomServer.id)
                if not table.find(AllIDs, serverId) then
                    table.insert(AllIDs, serverId)
                    writefile("NotSameServers.json", game:GetService('HttpService'):JSONEncode(AllIDs))
                    game:GetService("TeleportService"):TeleportToPlaceInstance(PlaceID, serverId, game.Players.LocalPlayer)
                    wait(4)
                end
            else
                error("No valid server found")
            end
        else
            error("No servers available")
        end
    else
        warn("Failed to fetch server data:", decoded)
    end
end

function Teleport()
    while wait() do
        pcall(function()
            TPReturner()
            if foundAnything ~= "" then
                TPReturner()
            end
        end)
    end
end

-- If you'd like to use a script before server hopping (Like an Automatic Chest collector), you can put the Teleport() after it has collected everything.
Teleport()
